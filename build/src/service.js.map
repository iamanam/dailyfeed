{"version":3,"sources":["../../server/src/service.js"],"names":["rootPath","process","env","join","__dirname","Promise","require","timeago","AutoService","updateInterval","updatedMerge","minCounter","nextUpdate","latestUpdates","serviceRunnng","nextClean","arg","sourceTitle","feedLength","fileName","params","TableName","Key","UpdateExpression","ExpressionAttributeValues","Date","now","ReturnValues","dataToWrite","feedsLength","length","saveFetchInfo","e","console","log","writeJson","getPath","err","error","latestFeedFetched","self","readdir","res","writeData","reverse","map","file","getFile","readJsonSync","resolve","key","reject","stat","c","updating","autoUpdateTime","parse","mtime","format","feed","promiseBind","allPromises","isUpdateRequired","push","all","result","age","seconds","maxLevel","extensions","ignore","param","fetchUpdateForAll","fetchUpdateAll","feedUpdate","keyName","mergeEach","mergedFeeds","module","exports"],"mappings":"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","file":"service.js","sourcesContent":["import serveFeed from \"./serveFeed\";\nimport source from \"../../config/source.json\";\nimport config from \"../../config/config.json\";\nimport findRemoveSync from \"find-remove\";\nimport { updateItem } from \"../db/helper.js\";\nimport timeAgo from \"timeago.js\";\nimport fs from \"fs-extra\";\nimport path from \"path\";\nconst rootPath = process.env.rootPath || path.join(__dirname, \"..\", \"..\");\nvar Promise = require(\"bluebird\");\nlet timeago = timeAgo();\nconst AutoService = class {\n  constructor(updateInterval) {\n    this.updateInterval = updateInterval; // this is config setting for update interval\n    this.updatedMerge = {}; // this will hold the lates updateed merge\n    this.minCounter = 0; // this will use to track passed min between instance\n    this.nextUpdate = \"\"; // this will return the remaining time\n    this.latestUpdates = {};\n    this.serviceRunnng = \"false\";\n    this.nextClean = \"\";\n  }\n  getPath(...arg) {\n    return path.join(rootPath, \"store\", ...arg);\n  }\n  saveFetchInfo(sourceTitle, feedLength, fileName) {\n    var params = {\n      TableName: \"FeedSourceInfo\",\n      Key: {\n        sourceTitle: sourceTitle\n      },\n      UpdateExpression: \"set lastFetched =:dt, feedItem = :item , fileName=:fileName\",\n      ExpressionAttributeValues: {\n        \":dt\": Date.now(),\n        \":item\": feedLength,\n        \":fileName\": fileName\n      },\n      ReturnValues: \"UPDATED_NEW\"\n    };\n    return updateItem(params);\n  }\n\n  writeData(sourceTitle, dataToWrite) {\n    // after merging happen feed length will change, so update the length\n    dataToWrite.feedsLength = Object.keys(dataToWrite[\"feeds\"]).length;\n    try {\n      // now save the fetching info in db\n      this.saveFetchInfo(\n        sourceTitle,\n        dataToWrite.feedsLength,\n        dataToWrite.fileName // its trick to find the latest file saved after index.json\n      );\n    } catch (e) {\n      console.log(e);\n    } finally {\n      // add the lastest merged source for use later\n      // now write the file in index.json\n      fs.writeJson(\n        this.getPath(sourceTitle, \"index.json\"),\n        dataToWrite,\n        err => {\n          if (err)\n            return console.error(\n              \"Index.json couldn't be saved. Reason :=> \\n\" + err\n            );\n          console.log(\"Index.json for %s saved!\", sourceTitle);\n        }\n      );\n    }\n  }\n  mergeEach(sourceTitle, latestFeedFetched) {\n    let self = this;\n    return new Promise(resolve => {\n      // find store folder for each source feed\n      fs.readdir(this.getPath(sourceTitle), (err, res) => {\n        // if err or file in dir is less than one then write latest latestFeedFetched as index.json\n        if (err || res.length === 0) {\n          return this.writeData(sourceTitle, latestFeedFetched);\n        }\n        // if there are more files then merge and write it in index.json\n        try {\n          if (typeof res === \"object\" && res.length >= 1) {\n            // let fileMergeTotal = {};\n            res.reverse().map(file => {\n              if (file === \"index.json\") return; // need to ignore index file as its our destination writie\n              let getFile = this.getPath(sourceTitle, file);\n              if (getFile || getFile !== \"\" || typeof getFile !== \"undefined\") {\n                // merge only feeds, so we keeping intact other properties of lastfetched while merging feeds only\n                latestFeedFetched[\"feeds\"] = Object.assign(\n                  {},\n                  latestFeedFetched[\"feeds\"],\n                  fs.readJsonSync(getFile)\n                );\n              }\n            });\n            // save updated latestfetched after merged saved as backup\n            self.updatedMerge[sourceTitle] = latestFeedFetched;\n            resolve(latestFeedFetched);\n          }\n        } catch (e) {\n          // if any occur at file system or in merging then at least write latestFeed in index.json\n          console.error(\"Error on Merging \\n\", e);\n        }\n      });\n    });\n  }\n  isUpdateRequired(key) {\n    return new Promise((resolve, reject) => {\n      fs.stat(this.getPath(key, \"index.json\"), (e, c) => {\n        if (e) return resolve(true);\n        let updateInterval = config.updating.autoUpdateTime * 60000;\n        if (Date.parse(c.mtime) + updateInterval >= Date.now()) {\n          console.log(\n            \"%s updated=> at %s Next update=> %s\",\n            key,\n            timeago.format(c.mtime),\n            timeago.format(Date.parse(c.mtime) + updateInterval)\n          );\n          return resolve(false);\n        }\n        resolve(true);\n      });\n    });\n  }\n  /**\n * This function fetch update by calling the serveFeed method\n * It calls out all the source titles included and call the mergeEachSourceFile to merge lates feeds\n * It also return the feeds for all source <object data=\"\" type=\"\"></object>\n * @param {object} lastUpdate - The last successful update to compare it with latest update\n * @returns Promise\n */\n  async fetchUpdateForAll() {\n    let self = this;\n    async function promiseBind(key) {\n      var feed = {};\n      feed[key] = await serveFeed(key, self.latestUpdates || {});\n      return Promise.resolve(feed);\n    }\n    let allPromises = [];\n    for (var key in source) {\n      // first check if update require before fetching then push if available\n      if (await self.isUpdateRequired(key)) allPromises.push(promiseBind(key));\n    }\n    // return false if there are nothing to fetch\n    return allPromises.length >= 1 ? Promise.all(allPromises) : false;\n  }\n\n  // after fetching files delete json files which is older than 12 hrs\n  deleteOldSource() {\n    let result = findRemoveSync(path.join(rootPath, \"store\"), {\n      age: { seconds: 3600 * 12 }, // 12 hr\n      maxLevel: 2,\n      extensions: \".json\",\n      ignore: \"index.json\"\n    });\n    console.log(\"Old json source file which were deleted :\", result);\n  }\n\n  async runService(param) {\n    let self = this;\n    try {\n      self.serviceRunnng = \"true\";\n      // at first delete outdated json files before merging occur\n      // self.deleteOldSource();\n      // now fetch latest updates\n      let fetchUpdateAll = await this.fetchUpdateForAll();\n      // after update finish then merge latest feeds with old feeds for each different source\n      if (fetchUpdateAll && typeof fetchUpdateAll === \"object\") {\n        fetchUpdateAll.map(async function(feedUpdate) {\n          let keyName = Object.keys(feedUpdate)[0];\n          // start merging\n          let mergedFeeds = await self.mergeEach(\n            keyName, // source title\n            feedUpdate[keyName] // source values as feeds\n          );\n          // after successful merging write in db and updated feeds in index.json\n          if (mergedFeeds) return self.writeData(keyName, mergedFeeds);\n          // if mergefeeds failed, then as alternative write latest updates ignore old feeds\n          return self.writeData(keyName, feedUpdate[keyName]);\n        });\n      }\n    } catch (e) {\n      console.log(e);\n    } finally {\n      self.serviceRunnng = \"false\";\n      self.nextUpdate = Date.now() + 60000 * config.updating.autoUpdateTime;\n    }\n  }\n};\nmodule.exports = AutoService;\n"]}