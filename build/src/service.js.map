{"version":3,"sources":["../../server/src/service.js"],"names":["rootPath","process","env","join","__dirname","Promise","require","AutoService","updateInterval","updatedMerge","minCounter","nextUpdate","latestUpdates","serviceRunnng","arg","sourceTitle","feedLength","fileName","params","TableName","Key","UpdateExpression","ExpressionAttributeValues","Date","now","ReturnValues","dataToWrite","feedsLength","length","saveFetchInfo","e","console","log","writeJson","getPath","err","error","latestFeedFetched","self","readdir","res","writeData","reverse","map","file","getFile","readJsonSync","resolve","key","feed","promiseBind","allPromises","push","all","result","age","seconds","maxLevel","extensions","param","fetchUpdateForAll","fetchUpdateAll","feedUpdate","keyName","mergeEach","mergedFeeds","module","exports"],"mappings":"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","file":"service.js","sourcesContent":["import serveFeed from \"./serveFeed\";\nimport source from \"../../config/source.json\";\nimport config from \"../../config/config.json\";\nimport findRemoveSync from \"find-remove\";\nimport { updateItem } from \"../db/helper.js\";\nimport fs from \"fs-extra\";\nimport path from \"path\";\nconst rootPath = process.env.rootPath || path.join(__dirname, \"..\", \"..\");\nvar Promise = require(\"bluebird\");\nconst AutoService = class {\n  constructor(updateInterval) {\n    this.updateInterval = updateInterval; // this is config setting for update interval\n    this.updatedMerge = {}; // this will hold the lates updateed merge\n    this.minCounter = 0; // this will use to track passed min between instance\n    this.nextUpdate = \"\"; // this will return the remaining time\n    this.latestUpdates = {};\n    this.serviceRunnng = \"false\";\n  }\n  getPath(...arg) {\n    return path.join(rootPath, \"store\", ...arg);\n  }\n  saveFetchInfo(sourceTitle, feedLength, fileName) {\n    var params = {\n      TableName: \"FeedSourceInfo\",\n      Key: {\n        sourceTitle: sourceTitle\n      },\n      UpdateExpression: \"set lastFetched =:dt, feedItem = :item , fileName=:fileName\",\n      ExpressionAttributeValues: {\n        \":dt\": Date.now(),\n        \":item\": feedLength,\n        \":fileName\": fileName\n      },\n      ReturnValues: \"UPDATED_NEW\"\n    };\n    return updateItem(params);\n  }\n\n  writeData(sourceTitle, dataToWrite) {\n    // after merging happen feed length will change, so update the length\n    dataToWrite.feedsLength = Object.keys(dataToWrite[\"feeds\"]).length;\n    try {\n      // now save the fetching info in db\n      this.saveFetchInfo(\n        sourceTitle,\n        dataToWrite.feedsLength,\n        dataToWrite.fileName // its trick to find the latest file saved after index.json\n      );\n    } catch (e) {\n      console.log(e);\n    } finally {\n      // add the lastest merged source for use later\n      // now write the file in index.json\n      fs.writeJson(\n        this.getPath(sourceTitle, \"index.json\"),\n        dataToWrite,\n        err => {\n          if (err)\n            return console.error(\n              \"Index.json couldn't be saved. Reason :=> \\n\" + err\n            );\n          console.log(\"Index.json for %s saved!\", sourceTitle);\n        }\n      );\n    }\n  }\n  mergeEach(sourceTitle, latestFeedFetched) {\n    let self = this;\n    return new Promise(resolve => {\n      // find store folder for each source feed\n      fs.readdir(this.getPath(sourceTitle), (err, res) => {\n        // if err or file in dir is less than one then write latest latestFeedFetched as index.json\n        if (err || res.length === 0) {\n          return this.writeData(sourceTitle, latestFeedFetched);\n        }\n        // if there are more files then merge and write it in index.json\n        try {\n          if (typeof res === \"object\" && res.length >= 1) {\n            // let fileMergeTotal = {};\n            res.reverse().map(file => {\n              if (file === \"index.json\") return; // need to ignore index file as its our destination writie\n              let getFile = this.getPath(sourceTitle, file);\n              if (getFile || getFile !== \"\" || typeof getFile !== \"undefined\") {\n                // merge only feeds, so we keeping intact other properties of lastfetched while merging feeds only\n                latestFeedFetched[\"feeds\"] = Object.assign(\n                  {},\n                  latestFeedFetched[\"feeds\"],\n                  fs.readJsonSync(getFile)\n                );\n              }\n            });\n            // save updated latestfetched after merged saved as backup\n            self.updatedMerge[sourceTitle] = latestFeedFetched;\n            resolve(latestFeedFetched);\n          }\n        } catch (e) {\n          // if any occur at file system or in merging then at least write latestFeed in index.json\n          console.error(\"Error on Merging \\n\", e);\n        }\n      });\n    });\n  }\n\n  /**\n * This function fetch update by calling the serveFeed method\n * It calls out all the source titles included and call the mergeEachSourceFile to merge lates feeds\n * It also return the feeds for all source <object data=\"\" type=\"\"></object>\n * @param {object} lastUpdate - The last successful update to compare it with latest update\n * @returns Promise\n */\n  async fetchUpdateForAll() {\n    let self = this;\n    async function promiseBind(key) {\n      var feed = {};\n      feed[key] = await serveFeed(key, self.latestUpdates || {});\n      return Promise.resolve(feed);\n    }\n    /*\n          fs.stat(this.getPath(key, \"index.json\"), (e, c) => {\n        if (e) return console.error(e);\n        let updateInterval = config.updating.autoUpdateTime * 60000;\n        if (Date.parse(c.mtime) + updateInterval >= Date.now())\n          console.log(\"Updating ignored.\");\n        else ;\n      });\n      */\n    var allPromises = [];\n    for (var key in source) {\n      allPromises.push(promiseBind(key));\n    }\n    return Promise.all(allPromises);\n  }\n\n  // after fetching files delete json files which is older than 12 hrs\n  deleteOldSource() {\n    let result = findRemoveSync(path.join(rootPath, \"store\"), {\n      age: { seconds: 3600 * 12 }, // 12 hr\n      maxLevel: 2,\n      extensions: \".json\"\n    });\n    console.log(\"Old json source file which were deleted :\", result);\n  }\n\n  async runService(param) {\n    let self = this;\n    try {\n      self.serviceRunnng = \"true\";\n      // at first delete outdated json files before merging occur\n      // self.deleteOldSource();\n      // now fetch latest updates\n      let fetchUpdateAll = await this.fetchUpdateForAll();\n      // after update finish then merge latest feeds with old feeds for each different source\n      fetchUpdateAll.map(async function(feedUpdate) {\n        let keyName = Object.keys(feedUpdate)[0];\n        // start merging\n        let mergedFeeds = await self.mergeEach(\n          keyName, // source title\n          feedUpdate[keyName] // source values as feeds\n        );\n        // after successful merging write in db and updated feeds in index.json\n        if (mergedFeeds) return self.writeData(keyName, mergedFeeds);\n        // if mergefeeds failed, then as alternative write latest updates ignore old feeds\n        return self.writeData(keyName, feedUpdate[keyName]);\n      });\n    } catch (e) {\n      console.log(e);\n    } finally {\n      self.serviceRunnng = \"false\";\n      self.nextUpdate = Date.now() + 60000 * config.updateInterval;\n    }\n  }\n};\n\nmodule.exports = AutoService;\n"]}